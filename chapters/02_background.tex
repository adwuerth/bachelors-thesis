\chapter{Background}

\section{vroom}
vroom currently uses hugepages and locks them using mlock to prevent the Kernel from swapping them out. This only enables the use of 2MiB hugepages and up, which can be disadvantageous for certain applications that would benefit from smaller page sizes.
By using the IOMMU, this way of handling memory becomes redundant, as the IOMMU often supports smaller page sizes.

\section{IOMMU}
The IOMMU works similarly to the MMU in the CPU, mapping physical addresses to virtual addresses.
The IOMMU does this by performing page table walks, through which a physcial address is translated to a virtual address.
To improve performance on the IOMMU, an IOTLB is used to cache translations.

\section{VFIO}
VFIO is a framework that enables the use of the IOMMU from userspace.

\section{IOMMUFD}
IOMMUFD is a user API for exposing DMA to userspace. It allows management of I/O address spaces (IOAS), enabling mapping/unmapping user space memory on the IOMMU.
It can be used in combination with VFIO to provide a more user-friendly interface.