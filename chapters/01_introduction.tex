\chapter{Introduction}\label{c:introduction}

During his speech "Null Reference: The Billion Dollar Mistake" in 2009, Tony Hoare, a renowned computer scientist, well known for the invention of Quick-sort, proposed the idea of how null pointers are the reason for at least a billion dollars in damages \cite{billiondollarmistake}. This quote could not be anymore important than at this time. In the July of 2024, Microsoft devices faced what has been described as the "most spectacular IT meltdown the world has ever seen" \cite{bloombergmeltdown}. This meltdown affected 8.5 million Microsoft Windows devices and severly impacting institutions including critical infrastructure like hospitals and airports \cite{bloomberg8milliondevices}. During the error analysis of Crowdstrike, the company which deployed the faulty code to the Windows kernel, it was soon clear that null pointer deferencing in C++ caused the systems to crash \cite{heisenullpointer}. In the root cause analysis paper by Crowdstrike it was revealed that proper compile time validation and missing runtime array bounds checks were a big part of the error \cite{crowdstrikerca}.

Poor code analysis and faulty error handling are common occurence in systems level code. The damage that can be done by a single ring 0 driver like Crowdstrike shows how critical it is to achieve memory safety. By using Rust, a memory-safe yet highly performant programming language with a restrictive compiler could drastically improve the security and memory safety. As even the Linux Kernel, which has stuck to C for more that 30 years not admitting any other languages like C++, now permits Rust code in its codebase, we can see Rusts impact on the systems development community \cite{linuxrustpull}.

But it is also necessary to look at the limits of Rusts memory-safety. While using Rust for a driver improves the overall safety inside of the process while not compensating on performance, direct memory and I/O operations have to be implemented in an unsafe way. A userspace driver using physical DMA addresses enables a device to practically have full access to the memory and potentially doing detrimental I/O operations. Malicious firmware attacks are a rising threat.
In order to enforce safety at the device level, we need to take use of the IOMMU, a safe way of doing direct memory accesses. The IOMMU acts as a layer of isolation between devices and the CPU. By using virtual addresses the IOMMU is able to provide a bigger virtual address space and enforce memory access rights \cite{OLS2007}.

This thesis lays its focus on analysing the effects and performance impact of using the IOMMU in the context of userspace I/O.
We demonstrate this by implementing IOMMU support on vroom, a NVMe driver written in Rust \cite{vroom}, and comparing it to using physical addresses. To implement the IOMMU functionality we use the Linux framework VFIO, which has the advantageous side effect of the driver being able to run without root privileges. Additionally we will be looking at IOMMUFD, a modern replacement for VFIO's IOMMU API.
