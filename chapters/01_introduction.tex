\chapter{Introduction}\label{c:introduction}

During his speech "Null Reference: The Billion Dollar Mistake" in 2009, Tony Hoare, a renowned computer scientist, well known for the invention of Quick-sort, proposed the idea of how null pointers are the reason for at least a billion dollars in damages \cite{billiondollarmistake}. This quote could not be more important than at this time. In July 2024, Microsoft devices faced what has been described as the "most spectacular IT meltdown the world has ever seen" \cite{bloombergmeltdown}. This meltdown affected 8.5 million Microsoft Windows devices and severely impacted public institutions, including critical infrastructure like hospitals and airports \cite{bloomberg8milliondevices}. During the error analysis of Crowdstrike, the company that deployed the faulty code to the Windows kernel, it was soon clear that null pointer deferencing in C++ caused the systems to crash \cite{heisenullpointer}. In the root cause analysis paper by Crowdstrike, it was revealed that proper compile time validation and missing runtime array bounds checks were a big part of the error \cite{crowdstrikerca}.

Poor code analysis and faulty error handling are common occurrences in system-level code. The damage that can be done by a single ring 0 driver like Crowdstrike's Falcon software shows how critical it is to achieve memory safety. By using Rust, a memory-safe yet highly performant programming language with a restrictive compiler, we could drastically improve security and memory safety. We can witness Rust's influence on the systems development community since even the Linux kernel, which has been using C for almost 30 years without accepting any other languages like C++, now allows Rust code in its codebase \cite{linuxrustpull}.

However, it's also important to consider Rusts safety limits. While using Rust for a driver improves the overall safety of the process while not compensating on performance, direct memory and I/O operations have to be implemented in an unsafe way. A userspace driver using physical DMA addresses enables a device to practically have full access to the memory and potentially do detrimental I/O operations. Malicious firmware attacks are a rising threat.
In order to enforce safety at the device level, we need to make use of the IOMMU, a safe way of doing direct memory accesses. The IOMMU acts as a layer of isolation between devices and the CPU. By using virtual addresses, the IOMMU is able to provide a bigger virtual address space and enforce memory access rights \cite{OLS2007}.

The primary goal of this thesis is to examine how the IOMMU impacts performance in the context of userspace I/O.
We demonstrate this by implementing IOMMU support on vroom, a NVMe driver written in Rust \cite{vroom}, and comparing it to using physical addresses. We use the Linux framework VFIO to implement the IOMMU functionality, which has the added benefit of enabling the driver to run without root privileges. Additionally, we will be looking at IOMMUFD, a modern replacement for VFIO's IOMMU API.
